/* automatically generated by rust-bindgen 0.59.1 */

pub const K4ABT_VERSION_MAJOR: u32 = 1;
pub const K4ABT_VERSION_MINOR: u32 = 1;
pub const K4ABT_VERSION_PATCH: u32 = 0;
pub const K4ABT_VERSION_PRERELEASE: &'static [u8; 1usize] = b"\0";
pub const K4ABT_VERSION_BUILD_METADATA: &'static [u8; 1usize] = b"\0";
pub const K4ABT_VERSION_STR: &'static [u8; 6usize] = b"1.1.0\0";
pub const K4ABT_DNN_MODEL_FILE: &'static [u8; 24usize] = b"dnn_model_2_0_op11.onnx\0";
pub const K4ABT_DNN_MODEL_FILE_LITE: &'static [u8; 29usize] = b"dnn_model_2_0_lite_op11.onnx\0";
pub const K4A_DEVICE_DEFAULT: u32 = 0;
pub const K4A_WAIT_INFINITE: i32 = -1;
pub const K4ABT_BODY_INDEX_MAP_BACKGROUND: u32 = 255;
pub const K4ABT_INVALID_BODY_ID: u32 = 4294967295;
pub const K4ABT_DEFAULT_TRACKER_SMOOTHING_FACTOR: f64 = 0.0;
pub type size_t = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _k4a_device_t {
    pub _rsvd: size_t,
}
#[test]
fn bindgen_test_layout__k4a_device_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_device_t>(),
        8usize,
        concat!("Size of: ", stringify!(_k4a_device_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_device_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_k4a_device_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_device_t>()))._rsvd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_t),
            "::",
            stringify!(_rsvd)
        )
    );
}
pub type k4a_device_t = *mut _k4a_device_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _k4a_capture_t {
    pub _rsvd: size_t,
}
#[test]
fn bindgen_test_layout__k4a_capture_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_capture_t>(),
        8usize,
        concat!("Size of: ", stringify!(_k4a_capture_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_capture_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_k4a_capture_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_capture_t>()))._rsvd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_capture_t),
            "::",
            stringify!(_rsvd)
        )
    );
}
pub type k4a_capture_t = *mut _k4a_capture_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _k4a_image_t {
    pub _rsvd: size_t,
}
#[test]
fn bindgen_test_layout__k4a_image_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_image_t>(),
        8usize,
        concat!("Size of: ", stringify!(_k4a_image_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_image_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_k4a_image_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_image_t>()))._rsvd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_image_t),
            "::",
            stringify!(_rsvd)
        )
    );
}
pub type k4a_image_t = *mut _k4a_image_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _k4a_transformation_t {
    pub _rsvd: size_t,
}
#[test]
fn bindgen_test_layout__k4a_transformation_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_transformation_t>(),
        8usize,
        concat!("Size of: ", stringify!(_k4a_transformation_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_transformation_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_k4a_transformation_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_transformation_t>()))._rsvd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_transformation_t),
            "::",
            stringify!(_rsvd)
        )
    );
}
pub type k4a_transformation_t = *mut _k4a_transformation_t;
#[repr(i32)]
#[doc = " Result code returned by Azure Kinect APIs."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum k4a_result_t {
    #[doc = "< The result was successful"]
    K4A_RESULT_SUCCEEDED = 0,
    #[doc = "< The result was a failure"]
    K4A_RESULT_FAILED = 1,
}
#[repr(i32)]
#[doc = " Result code returned by Azure Kinect APIs."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum k4a_buffer_result_t {
    #[doc = "< The result was successful"]
    K4A_BUFFER_RESULT_SUCCEEDED = 0,
    #[doc = "< The result was a failure"]
    K4A_BUFFER_RESULT_FAILED = 1,
    #[doc = "< The input buffer was too small"]
    K4A_BUFFER_RESULT_TOO_SMALL = 2,
}
#[repr(i32)]
#[doc = " Result code returned by Azure Kinect APIs."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum k4a_wait_result_t {
    #[doc = "< The result was successful"]
    K4A_WAIT_RESULT_SUCCEEDED = 0,
    #[doc = "< The result was a failure"]
    K4A_WAIT_RESULT_FAILED = 1,
    #[doc = "< The operation timed out"]
    K4A_WAIT_RESULT_TIMEOUT = 2,
}
#[repr(i32)]
#[doc = " Verbosity levels of debug messaging"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum k4a_log_level_t {
    #[doc = "< Most severe level of debug messaging."]
    K4A_LOG_LEVEL_CRITICAL = 0,
    #[doc = "< 2nd most severe level of debug messaging."]
    K4A_LOG_LEVEL_ERROR = 1,
    #[doc = "< 3nd most severe level of debug messaging."]
    K4A_LOG_LEVEL_WARNING = 2,
    #[doc = "< 2nd least severe level of debug messaging."]
    K4A_LOG_LEVEL_INFO = 3,
    #[doc = "< Least severe level of debug messaging."]
    K4A_LOG_LEVEL_TRACE = 4,
    #[doc = "< No logging is performed"]
    K4A_LOG_LEVEL_OFF = 5,
}
#[repr(i32)]
#[doc = " Depth sensor capture modes."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " See the hardware specification for additional details on the field of view, and supported frame rates"]
#[doc = " for each mode."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " NFOV and WFOV denote Narrow and Wide Field Of View configurations."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Binned modes reduce the captured camera resolution by combining adjacent sensor pixels into a bin."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum k4a_depth_mode_t {
    #[doc = "< Depth sensor will be turned off with this setting."]
    K4A_DEPTH_MODE_OFF = 0,
    #[doc = "< Depth captured at 320x288. Passive IR is also captured at 320x288."]
    K4A_DEPTH_MODE_NFOV_2X2BINNED = 1,
    #[doc = "< Depth captured at 640x576. Passive IR is also captured at 640x576."]
    K4A_DEPTH_MODE_NFOV_UNBINNED = 2,
    #[doc = "< Depth captured at 512x512. Passive IR is also captured at 512x512."]
    K4A_DEPTH_MODE_WFOV_2X2BINNED = 3,
    #[doc = "< Depth captured at 1024x1024. Passive IR is also captured at 1024x1024."]
    K4A_DEPTH_MODE_WFOV_UNBINNED = 4,
    #[doc = "< Passive IR only, captured at 1024x1024."]
    K4A_DEPTH_MODE_PASSIVE_IR = 5,
}
#[repr(i32)]
#[doc = " Color sensor resolutions."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum k4a_color_resolution_t {
    #[doc = "< Color camera will be turned off with this setting"]
    K4A_COLOR_RESOLUTION_OFF = 0,
    #[doc = "< 1280 * 720  16:9"]
    K4A_COLOR_RESOLUTION_720P = 1,
    #[doc = "< 1920 * 1080 16:9"]
    K4A_COLOR_RESOLUTION_1080P = 2,
    #[doc = "< 2560 * 1440 16:9"]
    K4A_COLOR_RESOLUTION_1440P = 3,
    #[doc = "< 2048 * 1536 4:3"]
    K4A_COLOR_RESOLUTION_1536P = 4,
    #[doc = "< 3840 * 2160 16:9"]
    K4A_COLOR_RESOLUTION_2160P = 5,
    #[doc = "< 4096 * 3072 4:3"]
    K4A_COLOR_RESOLUTION_3072P = 6,
}
#[repr(i32)]
#[doc = " Image format type."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " The image format indicates how the \\ref k4a_image_t buffer data is interpreted."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum k4a_image_format_t {
    #[doc = " Color image type MJPG."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " The buffer for each image is encoded as a JPEG and can be decoded by a JPEG decoder."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " Because the image is compressed, the stride parameter for the \\ref k4a_image_t is not applicable."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " Each MJPG encoded image in a stream may be of differing size depending on the compression efficiency."]
    K4A_IMAGE_FORMAT_COLOR_MJPG = 0,
    #[doc = " Color image type NV12."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " NV12 images separate the luminance and chroma data such that all the luminance is at the"]
    #[doc = " beginning of the buffer, and the chroma lines follow immediately after."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " Stride indicates the length of each line in bytes and should be used to determine the start location of each line"]
    #[doc = " of the image in memory. Chroma has half as many lines of height and half the width in pixels of the luminance."]
    #[doc = " Each chroma line has the same width in bytes as a luminance line."]
    K4A_IMAGE_FORMAT_COLOR_NV12 = 1,
    #[doc = " Color image type YUY2."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " YUY2 stores chroma and luminance data in interleaved pixels."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " Stride indicates the length of each line in bytes and should be used to determine the start location of each"]
    #[doc = " line of the image in memory."]
    K4A_IMAGE_FORMAT_COLOR_YUY2 = 2,
    #[doc = " Color image type BGRA32."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " Each pixel of BGRA32 data is four bytes. The first three bytes represent Blue, Green,"]
    #[doc = " and Red data. The fourth byte is the alpha channel and is unused in the Azure Kinect APIs."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " Stride indicates the length of each line in bytes and should be used to determine the start location of each"]
    #[doc = " line of the image in memory."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " The Azure Kinect device does not natively capture in this format. Requesting images of this format"]
    #[doc = " requires additional computation in the API."]
    #[doc = ""]
    K4A_IMAGE_FORMAT_COLOR_BGRA32 = 3,
    #[doc = " Depth image type DEPTH16."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " Each pixel of DEPTH16 data is two bytes of little endian unsigned depth data. The unit of the data is in"]
    #[doc = " millimeters from the origin of the camera."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " Stride indicates the length of each line in bytes and should be used to determine the start location of each"]
    #[doc = " line of the image in memory."]
    K4A_IMAGE_FORMAT_DEPTH16 = 4,
    #[doc = " Image type IR16."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " Each pixel of IR16 data is two bytes of little endian unsigned depth data. The value of the data represents"]
    #[doc = " brightness."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " This format represents infrared light and is captured by the depth camera."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " Stride indicates the length of each line in bytes and should be used to determine the start location of each"]
    #[doc = " line of the image in memory."]
    K4A_IMAGE_FORMAT_IR16 = 5,
    #[doc = " Single channel image type CUSTOM8."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " Each pixel of CUSTOM8 is a single channel one byte of unsigned data."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " Stride indicates the length of each line in bytes and should be used to determine the start location of each"]
    #[doc = " line of the image in memory."]
    K4A_IMAGE_FORMAT_CUSTOM8 = 6,
    #[doc = " Single channel image type CUSTOM16."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " Each pixel of CUSTOM16 is a single channel two bytes of little endian unsigned data."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " Stride indicates the length of each line in bytes and should be used to determine the start location of each"]
    #[doc = " line of the image in memory."]
    K4A_IMAGE_FORMAT_CUSTOM16 = 7,
    #[doc = " Custom image format."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " Used in conjunction with user created images or images packing non-standard data."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " See the originator of the custom formatted image for information on how to interpret the data."]
    K4A_IMAGE_FORMAT_CUSTOM = 8,
}
#[repr(i32)]
#[doc = " Transformation interpolation type."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Interpolation type used with k4a_transformation_depth_image_to_color_camera_custom."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum k4a_transformation_interpolation_type_t {
    #[doc = "< Nearest neighbor interpolation"]
    K4A_TRANSFORMATION_INTERPOLATION_TYPE_NEAREST = 0,
    #[doc = "< Linear interpolation"]
    K4A_TRANSFORMATION_INTERPOLATION_TYPE_LINEAR = 1,
}
#[repr(i32)]
#[doc = " Color and depth sensor frame rate."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " This enumeration is used to select the desired frame rate to operate the cameras. The actual"]
#[doc = " frame rate may vary slightly due to dropped data, synchronization variation between devices,"]
#[doc = " clock accuracy, or if the camera exposure priority mode causes reduced frame rate."]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum k4a_fps_t {
    #[doc = "< 5 FPS"]
    K4A_FRAMES_PER_SECOND_5 = 0,
    #[doc = "< 15 FPS"]
    K4A_FRAMES_PER_SECOND_15 = 1,
    #[doc = "< 30 FPS"]
    K4A_FRAMES_PER_SECOND_30 = 2,
}
#[repr(i32)]
#[doc = " Color sensor control commands"]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " The current settings can be read with k4a_device_get_color_control(). The settings can be set with"]
#[doc = " k4a_device_set_color_control()."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Control values set on a device are reset only when the device is power cycled. The device will retain the settings"]
#[doc = " even if the \\ref k4a_device_t is closed or the application is restarted."]
#[doc = ""]
#[doc = " \\see k4a_color_control_mode_t"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum k4a_color_control_command_t {
    #[doc = " Exposure time setting."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " May be set to ::K4A_COLOR_CONTROL_MODE_AUTO or ::K4A_COLOR_CONTROL_MODE_MANUAL."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " The Azure Kinect supports a limited number of fixed expsore settings. When setting this, expect the exposure to"]
    #[doc = " be rounded up to the nearest setting. Exceptions are 1) The last value in the table is the upper limit, so a"]
    #[doc = " value larger than this will be overridden to the largest entry in the table. 2) The exposure time cannot be"]
    #[doc = " larger than the equivelent FPS. So expect 100ms exposure time to be reduced to 30ms or 33.33ms when the camera is"]
    #[doc = " started. The most recent copy of the table 'device_exposure_mapping' is in"]
    #[doc = " https://github.com/microsoft/Azure-Kinect-Sensor-SDK/blob/develop/src/color/color_priv.h"]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " Exposure time is measured in microseconds."]
    K4A_COLOR_CONTROL_EXPOSURE_TIME_ABSOLUTE = 0,
    #[doc = " Exposure or Framerate priority setting."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " May only be set to ::K4A_COLOR_CONTROL_MODE_MANUAL."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " Value of 0 means framerate priority. Value of 1 means exposure priority."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " Using exposure priority may impact the framerate of both the color and depth cameras."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " Deprecated starting in 1.2.0. Please discontinue usage, firmware does not support this."]
    K4A_COLOR_CONTROL_AUTO_EXPOSURE_PRIORITY = 1,
    #[doc = " Brightness setting."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " May only be set to ::K4A_COLOR_CONTROL_MODE_MANUAL."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " The valid range is 0 to 255. The default value is 128."]
    K4A_COLOR_CONTROL_BRIGHTNESS = 2,
    #[doc = " Contrast setting."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " May only be set to ::K4A_COLOR_CONTROL_MODE_MANUAL."]
    K4A_COLOR_CONTROL_CONTRAST = 3,
    #[doc = " Saturation setting."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " May only be set to ::K4A_COLOR_CONTROL_MODE_MANUAL."]
    K4A_COLOR_CONTROL_SATURATION = 4,
    #[doc = " Sharpness setting."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " May only be set to ::K4A_COLOR_CONTROL_MODE_MANUAL."]
    K4A_COLOR_CONTROL_SHARPNESS = 5,
    #[doc = " White balance setting."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " May be set to ::K4A_COLOR_CONTROL_MODE_AUTO or ::K4A_COLOR_CONTROL_MODE_MANUAL."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " The unit is degrees Kelvin. The setting must be set to a value evenly divisible by 10 degrees."]
    K4A_COLOR_CONTROL_WHITEBALANCE = 6,
    #[doc = " Backlight compensation setting."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " May only be set to ::K4A_COLOR_CONTROL_MODE_MANUAL."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " Value of 0 means backlight compensation is disabled. Value of 1 means backlight compensation is enabled."]
    K4A_COLOR_CONTROL_BACKLIGHT_COMPENSATION = 7,
    #[doc = " Gain setting."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " May only be set to ::K4A_COLOR_CONTROL_MODE_MANUAL."]
    K4A_COLOR_CONTROL_GAIN = 8,
    #[doc = " Powerline frequency setting."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " May only be set to ::K4A_COLOR_CONTROL_MODE_MANUAL."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " Value of 1 sets the powerline compensation to 50 Hz. Value of 2 sets the powerline compensation to 60 Hz."]
    K4A_COLOR_CONTROL_POWERLINE_FREQUENCY = 9,
}
#[repr(i32)]
#[doc = " Color sensor control mode"]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " The current settings can be read with k4a_device_get_color_control(). The settings can be set with"]
#[doc = " k4a_device_set_color_control()."]
#[doc = ""]
#[doc = " \\see k4a_color_control_command_t"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum k4a_color_control_mode_t {
    #[doc = "< set the associated k4a_color_control_command_t to auto"]
    K4A_COLOR_CONTROL_MODE_AUTO = 0,
    #[doc = "< set the associated k4a_color_control_command_t to manual"]
    K4A_COLOR_CONTROL_MODE_MANUAL = 1,
}
#[repr(i32)]
#[doc = " Synchronization mode when connecting two or more devices together."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum k4a_wired_sync_mode_t {
    #[doc = "< Neither 'Sync In' or 'Sync Out' connections are used."]
    K4A_WIRED_SYNC_MODE_STANDALONE = 0,
    #[doc = "< The 'Sync Out' jack is enabled and synchronization data it driven out the"]
    #[doc = "connected wire. While in master mode the color camera must be enabled as part of the"]
    #[doc = "multi device sync signalling logic. Even if the color image is not needed, the color"]
    #[doc = "camera must be running."]
    K4A_WIRED_SYNC_MODE_MASTER = 1,
    #[doc = "< The 'Sync In' jack is used for synchronization and 'Sync Out' is driven for the"]
    #[doc = "next device in the chain. 'Sync Out' is a mirror of 'Sync In' for this mode."]
    K4A_WIRED_SYNC_MODE_SUBORDINATE = 2,
}
#[repr(i32)]
#[doc = " Calibration types."]
#[doc = ""]
#[doc = " Specifies a type of calibration."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum k4a_calibration_type_t {
    #[doc = "< Calibration type is unknown"]
    K4A_CALIBRATION_TYPE_UNKNOWN = -1,
    #[doc = "< Depth sensor"]
    K4A_CALIBRATION_TYPE_DEPTH = 0,
    #[doc = "< Color sensor"]
    K4A_CALIBRATION_TYPE_COLOR = 1,
    #[doc = "< Gyroscope sensor"]
    K4A_CALIBRATION_TYPE_GYRO = 2,
    #[doc = "< Accelerometer sensor"]
    K4A_CALIBRATION_TYPE_ACCEL = 3,
    #[doc = "< Number of types excluding unknown type"]
    K4A_CALIBRATION_TYPE_NUM = 4,
}
#[repr(i32)]
#[doc = " Calibration model type."]
#[doc = ""]
#[doc = " The model used interpret the calibration parameters."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Azure Kinect devices are calibrated with Brown Conrady."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum k4a_calibration_model_type_t {
    #[doc = "< Calibration model is unknown"]
    K4A_CALIBRATION_LENS_DISTORTION_MODEL_UNKNOWN = 0,
    #[doc = "< Deprecated (not supported). Calibration model is Theta (arctan)."]
    K4A_CALIBRATION_LENS_DISTORTION_MODEL_THETA = 1,
    #[doc = "< Deprecated (not supported). Calibration model is"]
    #[doc = "Polynomial 3K."]
    K4A_CALIBRATION_LENS_DISTORTION_MODEL_POLYNOMIAL_3K = 2,
    #[doc = "< Deprecated (only supported early internal devices)."]
    #[doc = "Calibration model is Rational 6KT."]
    K4A_CALIBRATION_LENS_DISTORTION_MODEL_RATIONAL_6KT = 3,
    #[doc = "< Calibration model is Brown Conrady (compatible with"]
    #[doc = " OpenCV)"]
    K4A_CALIBRATION_LENS_DISTORTION_MODEL_BROWN_CONRADY = 4,
}
#[repr(i32)]
#[doc = " Firmware build type."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum k4a_firmware_build_t {
    #[doc = "< Production firmware."]
    K4A_FIRMWARE_BUILD_RELEASE = 0,
    #[doc = "< Pre-production firmware."]
    K4A_FIRMWARE_BUILD_DEBUG = 1,
}
#[repr(i32)]
#[doc = " Firmware signature type."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum k4a_firmware_signature_t {
    #[doc = "< Microsoft signed firmware."]
    K4A_FIRMWARE_SIGNATURE_MSFT = 0,
    #[doc = "< Test signed firmware."]
    K4A_FIRMWARE_SIGNATURE_TEST = 1,
    #[doc = "< Unsigned firmware."]
    K4A_FIRMWARE_SIGNATURE_UNSIGNED = 2,
}
#[doc = " Callback function for debug messages being generated by the Azure Kinect SDK."]
#[doc = ""]
#[doc = " \\param context"]
#[doc = " The context of the callback function. This is the context that was supplied by the caller to \\p"]
#[doc = " k4a_set_debug_message_handler."]
#[doc = ""]
#[doc = " \\param level"]
#[doc = " The level of the message that has been created."]
#[doc = ""]
#[doc = " \\param file"]
#[doc = " The file name of the source file that generated the message."]
#[doc = ""]
#[doc = " \\param line"]
#[doc = " The line number of the source file that generated the message."]
#[doc = ""]
#[doc = " \\param message"]
#[doc = " The messaged generated by the Azure Kinect SDK."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " The callback is called asynchronously when the Azure Kinext SDK generates a message at a \\p level that is equal to"]
#[doc = " or more critical than the level specified when calling \\ref k4a_set_debug_message_handler() to register the callback."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " This callback can occur from any thread and blocks the calling thread. The k4a_logging_message_cb_t function user"]
#[doc = " must protect it's logging resources from concurrent calls. All care should be made to minimize the amount of time"]
#[doc = " locks are held."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[doc = ""]
pub type k4a_logging_message_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        level: k4a_log_level_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        message: *const ::std::os::raw::c_char,
    ),
>;
#[doc = " Callback function for a memory object being destroyed."]
#[doc = ""]
#[doc = " \\param buffer"]
#[doc = " The buffer pointer that was supplied by the caller as \\p buffer_release_cb to \\ref k4a_image_create_from_buffer()."]
#[doc = ""]
#[doc = " \\param context"]
#[doc = " The context for the memory object that needs to be destroyed that was supplied by the caller as \\p"]
#[doc = " buffer_release_cb_context to \\ref k4a_image_create_from_buffer()."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " When all references for the memory object are released, this callback will be invoked as the final destroy for the"]
#[doc = " given memory."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[doc = ""]
pub type k4a_memory_destroy_cb_t = ::std::option::Option<
    unsafe extern "C" fn(buffer: *mut ::std::os::raw::c_void, context: *mut ::std::os::raw::c_void),
>;
#[doc = " Callback function for a memory allocation."]
#[doc = ""]
#[doc = " \\param size"]
#[doc = " Minimum size in bytes needed for the buffer."]
#[doc = ""]
#[doc = " \\param context"]
#[doc = " Output parameter for a context that will be provided in the subsequent call to the \\ref k4a_memory_destroy_cb_t"]
#[doc = " callback."]
#[doc = ""]
#[doc = " \\return"]
#[doc = " A pointer to the newly allocated memory."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " A callback of this type is provided when there is an application defined allocator."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[doc = ""]
pub type k4a_memory_allocate_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        size: ::std::os::raw::c_int,
        context: *mut *mut ::std::os::raw::c_void,
    ) -> *mut u8,
>;
#[doc = " Configuration parameters for an Azure Kinect device."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Used by k4a_device_start_cameras() to specify the configuration of the data capture."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _k4a_device_configuration_t {
    #[doc = " Image format to capture with the color camera."]
    #[doc = ""]
    #[doc = " The color camera does not natively produce BGRA32 images."]
    #[doc = " Setting ::K4A_IMAGE_FORMAT_COLOR_BGRA32 for color_format will result in higher CPU utilization."]
    pub color_format: k4a_image_format_t,
    #[doc = " Image resolution to capture with the color camera."]
    pub color_resolution: k4a_color_resolution_t,
    #[doc = " Capture mode for the depth camera."]
    pub depth_mode: k4a_depth_mode_t,
    #[doc = " Desired frame rate for the color and depth camera."]
    pub camera_fps: k4a_fps_t,
    #[doc = " Only produce k4a_capture_t objects if they contain synchronized color and depth images."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " This setting controls the behavior in which images are dropped when images are produced faster than they can be"]
    #[doc = " read, or if there are errors in reading images from the device."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " If set to true, \\ref k4a_capture_t objects will only be produced with both color and depth images."]
    #[doc = " If set to false, \\ref k4a_capture_t objects may be produced only a single image when the corresponding image is"]
    #[doc = " dropped."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " Setting this to false ensures that the caller receives all of the images received from the camera, regardless of"]
    #[doc = " whether the corresponding images expected in the capture are available."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " If either the color or depth camera are disabled, this setting has no effect."]
    pub synchronized_images_only: bool,
    #[doc = " Desired delay between the capture of the color image and the capture of the depth image."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " A negative value indicates that the depth image should be captured before the color image."]
    #[doc = ""]
    #[doc = " \\details"]
    #[doc = " Any value between negative and positive one capture period is valid."]
    pub depth_delay_off_color_usec: i32,
    #[doc = " The external synchronization mode."]
    pub wired_sync_mode: k4a_wired_sync_mode_t,
    #[doc = " The external synchronization timing."]
    #[doc = ""]
    #[doc = " If this camera is a subordinate, this sets the capture delay between the color camera capture and the external"]
    #[doc = " input pulse. A setting of zero indicates that the master and subordinate color images should be aligned."]
    #[doc = ""]
    #[doc = " This setting does not effect the 'Sync out' connection."]
    #[doc = ""]
    #[doc = " This value must be positive and range from zero to one capture period."]
    #[doc = ""]
    #[doc = " If this is not a subordinate, then this value is ignored."]
    pub subordinate_delay_off_master_usec: u32,
    #[doc = " Streaming indicator automatically turns on when the color or depth camera's are in use."]
    #[doc = ""]
    #[doc = " This setting disables that behavior and keeps the LED in an off state."]
    pub disable_streaming_indicator: bool,
}
#[test]
fn bindgen_test_layout__k4a_device_configuration_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_device_configuration_t>(),
        36usize,
        concat!("Size of: ", stringify!(_k4a_device_configuration_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_device_configuration_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_k4a_device_configuration_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_device_configuration_t>())).color_format as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_configuration_t),
            "::",
            stringify!(color_format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_device_configuration_t>())).color_resolution as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_configuration_t),
            "::",
            stringify!(color_resolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_device_configuration_t>())).depth_mode as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_configuration_t),
            "::",
            stringify!(depth_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_device_configuration_t>())).camera_fps as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_configuration_t),
            "::",
            stringify!(camera_fps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_device_configuration_t>())).synchronized_images_only
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_configuration_t),
            "::",
            stringify!(synchronized_images_only)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_device_configuration_t>())).depth_delay_off_color_usec
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_configuration_t),
            "::",
            stringify!(depth_delay_off_color_usec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_device_configuration_t>())).wired_sync_mode as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_configuration_t),
            "::",
            stringify!(wired_sync_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_device_configuration_t>()))
                .subordinate_delay_off_master_usec as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_configuration_t),
            "::",
            stringify!(subordinate_delay_off_master_usec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_device_configuration_t>())).disable_streaming_indicator
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_device_configuration_t),
            "::",
            stringify!(disable_streaming_indicator)
        )
    );
}
#[doc = " Configuration parameters for an Azure Kinect device."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Used by k4a_device_start_cameras() to specify the configuration of the data capture."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_device_configuration_t = _k4a_device_configuration_t;
#[doc = " Extrinsic calibration data."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Extrinsic calibration defines the physical relationship between two separate devices."]
#[doc = ""]
#[doc = " \\relates k4a_calibration_camera_t"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _k4a_calibration_extrinsics_t {
    #[doc = "< 3x3 Rotation matrix stored in row major order"]
    pub rotation: [f32; 9usize],
    #[doc = "< Translation vector, x,y,z (in millimeters)"]
    pub translation: [f32; 3usize],
}
#[test]
fn bindgen_test_layout__k4a_calibration_extrinsics_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_calibration_extrinsics_t>(),
        48usize,
        concat!("Size of: ", stringify!(_k4a_calibration_extrinsics_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_calibration_extrinsics_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_k4a_calibration_extrinsics_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_extrinsics_t>())).rotation as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_extrinsics_t),
            "::",
            stringify!(rotation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_extrinsics_t>())).translation as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_extrinsics_t),
            "::",
            stringify!(translation)
        )
    );
}
#[doc = " Extrinsic calibration data."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Extrinsic calibration defines the physical relationship between two separate devices."]
#[doc = ""]
#[doc = " \\relates k4a_calibration_camera_t"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_calibration_extrinsics_t = _k4a_calibration_extrinsics_t;
#[doc = " Camera intrinsic calibration data."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Intrinsic calibration represents the internal optical properties of the camera."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Azure Kinect devices are calibrated with Brown Conrady which is compatible"]
#[doc = " with OpenCV."]
#[doc = ""]
#[doc = " \\relates k4a_calibration_camera_t"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union k4a_calibration_intrinsic_parameters_t {
    #[doc = "< Individual parameter representation of intrinsic model"]
    pub param: k4a_calibration_intrinsic_parameters_t__param,
    #[doc = "< Array representation of intrinsic model parameters"]
    pub v: [f32; 15usize],
}
#[doc = " individual parameter or array representation of intrinsic model."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k4a_calibration_intrinsic_parameters_t__param {
    #[doc = "< Principal point in image, x"]
    pub cx: f32,
    #[doc = "< Principal point in image, y"]
    pub cy: f32,
    #[doc = "< Focal length x"]
    pub fx: f32,
    #[doc = "< Focal length y"]
    pub fy: f32,
    #[doc = "< k1 radial distortion coefficient"]
    pub k1: f32,
    #[doc = "< k2 radial distortion coefficient"]
    pub k2: f32,
    #[doc = "< k3 radial distortion coefficient"]
    pub k3: f32,
    #[doc = "< k4 radial distortion coefficient"]
    pub k4: f32,
    #[doc = "< k5 radial distortion coefficient"]
    pub k5: f32,
    #[doc = "< k6 radial distortion coefficient"]
    pub k6: f32,
    #[doc = "< Center of distortion in Z=1 plane, x (only used for Rational6KT)"]
    pub codx: f32,
    #[doc = "< Center of distortion in Z=1 plane, y (only used for Rational6KT)"]
    pub cody: f32,
    #[doc = "< Tangential distortion coefficient 2"]
    pub p2: f32,
    #[doc = "< Tangential distortion coefficient 1"]
    pub p1: f32,
    #[doc = "< Metric radius"]
    pub metric_radius: f32,
}
#[test]
fn bindgen_test_layout_k4a_calibration_intrinsic_parameters_t__param() {
    assert_eq!(
        ::std::mem::size_of::<k4a_calibration_intrinsic_parameters_t__param>(),
        60usize,
        concat!(
            "Size of: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<k4a_calibration_intrinsic_parameters_t__param>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).cx as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).cy as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(cy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).fx as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(fx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).fy as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(fy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).k1 as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(k1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).k2 as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(k2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).k3 as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(k3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).k4 as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(k4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).k5 as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(k5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).k6 as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(k6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).codx
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(codx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).cody
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(cody)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).p2 as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(p2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).p1 as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(p1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t__param>())).metric_radius
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t__param),
            "::",
            stringify!(metric_radius)
        )
    );
}
#[test]
fn bindgen_test_layout_k4a_calibration_intrinsic_parameters_t() {
    assert_eq!(
        ::std::mem::size_of::<k4a_calibration_intrinsic_parameters_t>(),
        60usize,
        concat!(
            "Size of: ",
            stringify!(k4a_calibration_intrinsic_parameters_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<k4a_calibration_intrinsic_parameters_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(k4a_calibration_intrinsic_parameters_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t>())).param as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t),
            "::",
            stringify!(param)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k4a_calibration_intrinsic_parameters_t>())).v as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_calibration_intrinsic_parameters_t),
            "::",
            stringify!(v)
        )
    );
}
#[doc = " Camera sensor intrinsic calibration data."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Intrinsic calibration represents the internal optical properties of the camera."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Azure Kinect devices are calibrated with Brown Conrady which is compatible"]
#[doc = " with OpenCV."]
#[doc = ""]
#[doc = " \\relates k4a_calibration_camera_t"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _k4a_calibration_intrinsics_t {
    #[doc = "< Type of calibration model used"]
    pub type_: k4a_calibration_model_type_t,
    #[doc = "< Number of valid entries in parameters"]
    pub parameter_count: ::std::os::raw::c_uint,
    #[doc = "< Calibration parameters"]
    pub parameters: k4a_calibration_intrinsic_parameters_t,
}
#[test]
fn bindgen_test_layout__k4a_calibration_intrinsics_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_calibration_intrinsics_t>(),
        68usize,
        concat!("Size of: ", stringify!(_k4a_calibration_intrinsics_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_calibration_intrinsics_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_k4a_calibration_intrinsics_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_intrinsics_t>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_intrinsics_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_intrinsics_t>())).parameter_count as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_intrinsics_t),
            "::",
            stringify!(parameter_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_intrinsics_t>())).parameters as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_intrinsics_t),
            "::",
            stringify!(parameters)
        )
    );
}
#[doc = " Camera sensor intrinsic calibration data."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Intrinsic calibration represents the internal optical properties of the camera."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Azure Kinect devices are calibrated with Brown Conrady which is compatible"]
#[doc = " with OpenCV."]
#[doc = ""]
#[doc = " \\relates k4a_calibration_camera_t"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_calibration_intrinsics_t = _k4a_calibration_intrinsics_t;
#[doc = " Camera calibration contains intrinsic and extrinsic calibration information for a camera."]
#[doc = ""]
#[doc = " \\relates k4a_calibration_camera_t"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _k4a_calibration_camera_t {
    #[doc = "< Extrinsic calibration data."]
    pub extrinsics: k4a_calibration_extrinsics_t,
    #[doc = "< Intrinsic calibration data."]
    pub intrinsics: k4a_calibration_intrinsics_t,
    #[doc = "< Resolution width of the calibration sensor."]
    pub resolution_width: ::std::os::raw::c_int,
    #[doc = "< Resolution height of the calibration sensor."]
    pub resolution_height: ::std::os::raw::c_int,
    #[doc = "< Max FOV of the camera."]
    pub metric_radius: f32,
}
#[test]
fn bindgen_test_layout__k4a_calibration_camera_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_calibration_camera_t>(),
        128usize,
        concat!("Size of: ", stringify!(_k4a_calibration_camera_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_calibration_camera_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_k4a_calibration_camera_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_camera_t>())).extrinsics as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_camera_t),
            "::",
            stringify!(extrinsics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_camera_t>())).intrinsics as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_camera_t),
            "::",
            stringify!(intrinsics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_camera_t>())).resolution_width as *const _
                as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_camera_t),
            "::",
            stringify!(resolution_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_camera_t>())).resolution_height as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_camera_t),
            "::",
            stringify!(resolution_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_camera_t>())).metric_radius as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_camera_t),
            "::",
            stringify!(metric_radius)
        )
    );
}
#[doc = " Camera calibration contains intrinsic and extrinsic calibration information for a camera."]
#[doc = ""]
#[doc = " \\relates k4a_calibration_camera_t"]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_calibration_camera_t = _k4a_calibration_camera_t;
#[doc = " Calibration type representing device calibration."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _k4a_calibration_t {
    #[doc = "< Depth camera calibration."]
    pub depth_camera_calibration: k4a_calibration_camera_t,
    #[doc = "< Color camera calibration."]
    pub color_camera_calibration: k4a_calibration_camera_t,
    #[doc = " Extrinsic transformation parameters."]
    #[doc = ""]
    #[doc = " The extrinsic parameters allow 3D coordinate conversions between depth camera, color camera, the IMU's gyroscope"]
    #[doc = " and accelerometer. To transform from a source to a target 3D coordinate system, use the parameters stored"]
    #[doc = " under extrinsics[source][target]."]
    pub extrinsics: [[k4a_calibration_extrinsics_t; 4usize]; 4usize],
    #[doc = "< Depth camera mode for which calibration was obtained."]
    pub depth_mode: k4a_depth_mode_t,
    #[doc = "< Color camera resolution for which calibration was obtained."]
    pub color_resolution: k4a_color_resolution_t,
}
#[test]
fn bindgen_test_layout__k4a_calibration_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_calibration_t>(),
        1032usize,
        concat!("Size of: ", stringify!(_k4a_calibration_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_calibration_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_k4a_calibration_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_t>())).depth_camera_calibration as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_t),
            "::",
            stringify!(depth_camera_calibration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_t>())).color_camera_calibration as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_t),
            "::",
            stringify!(color_camera_calibration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_calibration_t>())).extrinsics as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_t),
            "::",
            stringify!(extrinsics)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_calibration_t>())).depth_mode as *const _ as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_t),
            "::",
            stringify!(depth_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_calibration_t>())).color_resolution as *const _ as usize
        },
        1028usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_calibration_t),
            "::",
            stringify!(color_resolution)
        )
    );
}
#[doc = " Calibration type representing device calibration."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_calibration_t = _k4a_calibration_t;
#[doc = " Version information."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _k4a_version_t {
    #[doc = "< Major version; represents a breaking change."]
    pub major: u32,
    #[doc = "< Minor version; represents additional features, no regression from lower versions with same"]
    #[doc = "major version."]
    pub minor: u32,
    #[doc = "< Reserved."]
    pub iteration: u32,
}
#[test]
fn bindgen_test_layout__k4a_version_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_version_t>(),
        12usize,
        concat!("Size of: ", stringify!(_k4a_version_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_version_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_k4a_version_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_version_t>())).major as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_version_t),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_version_t>())).minor as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_version_t),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_version_t>())).iteration as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_version_t),
            "::",
            stringify!(iteration)
        )
    );
}
#[doc = " Version information."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_version_t = _k4a_version_t;
#[doc = " Structure to define hardware version."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _k4a_hardware_version_t {
    #[doc = "< Color camera firmware version."]
    pub rgb: k4a_version_t,
    #[doc = "< Depth camera firmware version."]
    pub depth: k4a_version_t,
    #[doc = "< Audio device firmware version."]
    pub audio: k4a_version_t,
    #[doc = "< Depth sensor firmware version."]
    pub depth_sensor: k4a_version_t,
    #[doc = "< Build type reported by the firmware."]
    pub firmware_build: k4a_firmware_build_t,
    #[doc = "< Signature type of the firmware."]
    pub firmware_signature: k4a_firmware_signature_t,
}
#[test]
fn bindgen_test_layout__k4a_hardware_version_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_hardware_version_t>(),
        56usize,
        concat!("Size of: ", stringify!(_k4a_hardware_version_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_hardware_version_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_k4a_hardware_version_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_hardware_version_t>())).rgb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_hardware_version_t),
            "::",
            stringify!(rgb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_hardware_version_t>())).depth as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_hardware_version_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_hardware_version_t>())).audio as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_hardware_version_t),
            "::",
            stringify!(audio)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_hardware_version_t>())).depth_sensor as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_hardware_version_t),
            "::",
            stringify!(depth_sensor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_hardware_version_t>())).firmware_build as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_hardware_version_t),
            "::",
            stringify!(firmware_build)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_hardware_version_t>())).firmware_signature as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_hardware_version_t),
            "::",
            stringify!(firmware_signature)
        )
    );
}
#[doc = " Structure to define hardware version."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_hardware_version_t = _k4a_hardware_version_t;
#[doc = " Two dimensional floating point vector."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union k4a_float2_t {
    #[doc = "< X, Y representation of a vector"]
    pub xy: k4a_float2_t__xy,
    #[doc = "< Array representation of a vector"]
    pub v: [f32; 2usize],
}
#[doc = " XY or array representation of vector"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k4a_float2_t__xy {
    #[doc = "< X component of a vector"]
    pub x: f32,
    #[doc = "< Y component of a vector"]
    pub y: f32,
}
#[test]
fn bindgen_test_layout_k4a_float2_t__xy() {
    assert_eq!(
        ::std::mem::size_of::<k4a_float2_t__xy>(),
        8usize,
        concat!("Size of: ", stringify!(k4a_float2_t__xy))
    );
    assert_eq!(
        ::std::mem::align_of::<k4a_float2_t__xy>(),
        4usize,
        concat!("Alignment of ", stringify!(k4a_float2_t__xy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k4a_float2_t__xy>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_float2_t__xy),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k4a_float2_t__xy>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_float2_t__xy),
            "::",
            stringify!(y)
        )
    );
}
#[test]
fn bindgen_test_layout_k4a_float2_t() {
    assert_eq!(
        ::std::mem::size_of::<k4a_float2_t>(),
        8usize,
        concat!("Size of: ", stringify!(k4a_float2_t))
    );
    assert_eq!(
        ::std::mem::align_of::<k4a_float2_t>(),
        4usize,
        concat!("Alignment of ", stringify!(k4a_float2_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k4a_float2_t>())).xy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_float2_t),
            "::",
            stringify!(xy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k4a_float2_t>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_float2_t),
            "::",
            stringify!(v)
        )
    );
}
#[doc = " Three dimensional floating point vector."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union k4a_float3_t {
    #[doc = "< X, Y, Z representation of a vector."]
    pub xyz: k4a_float3_t__xyz,
    #[doc = "< Array representation of a vector."]
    pub v: [f32; 3usize],
}
#[doc = " XYZ or array representation of vector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k4a_float3_t__xyz {
    #[doc = "< X component of a vector."]
    pub x: f32,
    #[doc = "< Y component of a vector."]
    pub y: f32,
    #[doc = "< Z component of a vector."]
    pub z: f32,
}
#[test]
fn bindgen_test_layout_k4a_float3_t__xyz() {
    assert_eq!(
        ::std::mem::size_of::<k4a_float3_t__xyz>(),
        12usize,
        concat!("Size of: ", stringify!(k4a_float3_t__xyz))
    );
    assert_eq!(
        ::std::mem::align_of::<k4a_float3_t__xyz>(),
        4usize,
        concat!("Alignment of ", stringify!(k4a_float3_t__xyz))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k4a_float3_t__xyz>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_float3_t__xyz),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k4a_float3_t__xyz>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_float3_t__xyz),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k4a_float3_t__xyz>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_float3_t__xyz),
            "::",
            stringify!(z)
        )
    );
}
#[test]
fn bindgen_test_layout_k4a_float3_t() {
    assert_eq!(
        ::std::mem::size_of::<k4a_float3_t>(),
        12usize,
        concat!("Size of: ", stringify!(k4a_float3_t))
    );
    assert_eq!(
        ::std::mem::align_of::<k4a_float3_t>(),
        4usize,
        concat!("Alignment of ", stringify!(k4a_float3_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k4a_float3_t>())).xyz as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_float3_t),
            "::",
            stringify!(xyz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k4a_float3_t>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_float3_t),
            "::",
            stringify!(v)
        )
    );
}
#[doc = " IMU sample."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _k4a_imu_sample_t {
    #[doc = "< Temperature reading of this sample (Celsius)."]
    pub temperature: f32,
    #[doc = "< Accelerometer sample in meters per second squared."]
    pub acc_sample: k4a_float3_t,
    #[doc = "< Timestamp of the accelerometer in microseconds."]
    pub acc_timestamp_usec: u64,
    #[doc = "< Gyro sample in radians per second."]
    pub gyro_sample: k4a_float3_t,
    #[doc = "< Timestamp of the gyroscope in microseconds"]
    pub gyro_timestamp_usec: u64,
}
#[test]
fn bindgen_test_layout__k4a_imu_sample_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4a_imu_sample_t>(),
        48usize,
        concat!("Size of: ", stringify!(_k4a_imu_sample_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4a_imu_sample_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_k4a_imu_sample_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_imu_sample_t>())).temperature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_imu_sample_t),
            "::",
            stringify!(temperature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_imu_sample_t>())).acc_sample as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_imu_sample_t),
            "::",
            stringify!(acc_sample)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_imu_sample_t>())).acc_timestamp_usec as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_imu_sample_t),
            "::",
            stringify!(acc_timestamp_usec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4a_imu_sample_t>())).gyro_sample as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_imu_sample_t),
            "::",
            stringify!(gyro_sample)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4a_imu_sample_t>())).gyro_timestamp_usec as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4a_imu_sample_t),
            "::",
            stringify!(gyro_timestamp_usec)
        )
    );
}
#[doc = " IMU sample."]
#[doc = ""]
#[doc = " \\xmlonly"]
#[doc = " <requirements>"]
#[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
#[doc = " </requirements>"]
#[doc = " \\endxmlonly"]
pub type k4a_imu_sample_t = _k4a_imu_sample_t;
extern "C" {
    #[doc = " Initial configuration setting for disabling all sensors."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Use this setting to initialize a \\ref k4a_device_configuration_t to a disabled state."]
    #[doc = ""]
    #[doc = " \\xmlonly"]
    #[doc = " <requirements>"]
    #[doc = "   <requirement name=\"Header\">k4atypes.h (include k4a/k4a.h)</requirement>"]
    #[doc = " </requirements>"]
    #[doc = " \\endxmlonly"]
    pub static K4A_DEVICE_CONFIG_INIT_DISABLE_ALL: k4a_device_configuration_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _k4abt_tracker_t {
    pub _rsvd: size_t,
}
#[test]
fn bindgen_test_layout__k4abt_tracker_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4abt_tracker_t>(),
        8usize,
        concat!("Size of: ", stringify!(_k4abt_tracker_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4abt_tracker_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_k4abt_tracker_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4abt_tracker_t>()))._rsvd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4abt_tracker_t),
            "::",
            stringify!(_rsvd)
        )
    );
}
pub type k4abt_tracker_t = *mut _k4abt_tracker_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _k4abt_frame_t {
    pub _rsvd: size_t,
}
#[test]
fn bindgen_test_layout__k4abt_frame_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4abt_frame_t>(),
        8usize,
        concat!("Size of: ", stringify!(_k4abt_frame_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4abt_frame_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_k4abt_frame_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4abt_frame_t>()))._rsvd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4abt_frame_t),
            "::",
            stringify!(_rsvd)
        )
    );
}
pub type k4abt_frame_t = *mut _k4abt_frame_t;
#[repr(i32)]
#[doc = " Model fitting joint definition"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum k4abt_joint_id_t {
    K4ABT_JOINT_PELVIS = 0,
    K4ABT_JOINT_SPINE_NAVEL = 1,
    K4ABT_JOINT_SPINE_CHEST = 2,
    K4ABT_JOINT_NECK = 3,
    K4ABT_JOINT_CLAVICLE_LEFT = 4,
    K4ABT_JOINT_SHOULDER_LEFT = 5,
    K4ABT_JOINT_ELBOW_LEFT = 6,
    K4ABT_JOINT_WRIST_LEFT = 7,
    K4ABT_JOINT_HAND_LEFT = 8,
    K4ABT_JOINT_HANDTIP_LEFT = 9,
    K4ABT_JOINT_THUMB_LEFT = 10,
    K4ABT_JOINT_CLAVICLE_RIGHT = 11,
    K4ABT_JOINT_SHOULDER_RIGHT = 12,
    K4ABT_JOINT_ELBOW_RIGHT = 13,
    K4ABT_JOINT_WRIST_RIGHT = 14,
    K4ABT_JOINT_HAND_RIGHT = 15,
    K4ABT_JOINT_HANDTIP_RIGHT = 16,
    K4ABT_JOINT_THUMB_RIGHT = 17,
    K4ABT_JOINT_HIP_LEFT = 18,
    K4ABT_JOINT_KNEE_LEFT = 19,
    K4ABT_JOINT_ANKLE_LEFT = 20,
    K4ABT_JOINT_FOOT_LEFT = 21,
    K4ABT_JOINT_HIP_RIGHT = 22,
    K4ABT_JOINT_KNEE_RIGHT = 23,
    K4ABT_JOINT_ANKLE_RIGHT = 24,
    K4ABT_JOINT_FOOT_RIGHT = 25,
    K4ABT_JOINT_HEAD = 26,
    K4ABT_JOINT_NOSE = 27,
    K4ABT_JOINT_EYE_LEFT = 28,
    K4ABT_JOINT_EAR_LEFT = 29,
    K4ABT_JOINT_EYE_RIGHT = 30,
    K4ABT_JOINT_EAR_RIGHT = 31,
    K4ABT_JOINT_COUNT = 32,
}
#[repr(i32)]
#[doc = " Sensor mounting orientation types."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " This enumeration specifies the sensor mounting orientation. Passing the correct orientation in k4abt_tracker_create()"]
#[doc = " can help the body tracker to achieve more accurate body tracking."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " The sensor orientation is defined while facing the camera."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum k4abt_sensor_orientation_t {
    #[doc = "< Mount the sensor at its default orientation"]
    K4ABT_SENSOR_ORIENTATION_DEFAULT = 0,
    #[doc = "< Clockwisely rotate the sensor 90 degree"]
    K4ABT_SENSOR_ORIENTATION_CLOCKWISE90 = 1,
    #[doc = "< Counter-clockwisely rotate the sensor 90 degrees"]
    K4ABT_SENSOR_ORIENTATION_COUNTERCLOCKWISE90 = 2,
    #[doc = "< Mount the sensor upside-down"]
    K4ABT_SENSOR_ORIENTATION_FLIP180 = 3,
}
#[repr(i32)]
#[doc = " Tracker processing mode types."]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " The CPU only mode doesn't require the machine to have a GPU to run this SDK. But it will be much slower"]
#[doc = " than the GPU mode."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum k4abt_tracker_processing_mode_t {
    #[doc = "< SDK will use the most appropriate GPU mode for the operating system to run the tracker */"]
    K4ABT_TRACKER_PROCESSING_MODE_GPU = 0,
    #[doc = "< SDK will use CPU only mode to run the tracker"]
    K4ABT_TRACKER_PROCESSING_MODE_CPU = 1,
    #[doc = "< SDK will use ONNX Cuda EP to run the tracker"]
    K4ABT_TRACKER_PROCESSING_MODE_GPU_CUDA = 2,
    #[doc = "< SDK will use ONNX TensorRT EP to run the tracker"]
    K4ABT_TRACKER_PROCESSING_MODE_GPU_TENSORRT = 3,
    #[doc = "< SDK will use ONNX DirectML EP to run the tracker (Windows only)"]
    K4ABT_TRACKER_PROCESSING_MODE_GPU_DIRECTML = 4,
}
#[doc = " Configuration parameters for a k4abt body tracker"]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Used by k4abt_tracker_create() to specify the configuration of the k4abt tracker"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _k4abt_tracker_configuration_t {
    #[doc = " The sensor mounting orientation type."]
    #[doc = ""]
    #[doc = " Setting the correct orientation can help the body tracker to achieve more accurate body tracking results"]
    pub sensor_orientation: k4abt_sensor_orientation_t,
    #[doc = " Specify whether to use CPU only mode or GPU mode to run the tracker."]
    #[doc = ""]
    #[doc = " The CPU only mode doesn't require the machine to have a GPU to run this SDK. But it will be much slower"]
    #[doc = " than the GPU mode."]
    pub processing_mode: k4abt_tracker_processing_mode_t,
    #[doc = " Specify the GPU device ID to run the tracker."]
    #[doc = ""]
    #[doc = " The setting is only effective if the processing_mode setting is set to K4ABT_TRACKER_PROCESSING_MODE_GPU."]
    pub gpu_device_id: i32,
    #[doc = " Specify the model file name and location used by the tracker."]
    #[doc = ""]
    #[doc = " If specified, the tracker will use this model instead of the default one."]
    pub model_path: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__k4abt_tracker_configuration_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4abt_tracker_configuration_t>(),
        24usize,
        concat!("Size of: ", stringify!(_k4abt_tracker_configuration_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4abt_tracker_configuration_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_k4abt_tracker_configuration_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4abt_tracker_configuration_t>())).sensor_orientation
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4abt_tracker_configuration_t),
            "::",
            stringify!(sensor_orientation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4abt_tracker_configuration_t>())).processing_mode as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4abt_tracker_configuration_t),
            "::",
            stringify!(processing_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4abt_tracker_configuration_t>())).gpu_device_id as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4abt_tracker_configuration_t),
            "::",
            stringify!(gpu_device_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_k4abt_tracker_configuration_t>())).model_path as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4abt_tracker_configuration_t),
            "::",
            stringify!(model_path)
        )
    );
}
#[doc = " Configuration parameters for a k4abt body tracker"]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " Used by k4abt_tracker_create() to specify the configuration of the k4abt tracker"]
pub type k4abt_tracker_configuration_t = _k4abt_tracker_configuration_t;
#[doc = " k4a_quaternion_t"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union k4a_quaternion_t {
    #[doc = "< W, X, Y, Z representation of a quaternion"]
    pub wxyz: k4a_quaternion_t__wxyz,
    #[doc = "< Array representation of a quaternion"]
    pub v: [f32; 4usize],
}
#[doc = " WXYZ or array representation of quaternion"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k4a_quaternion_t__wxyz {
    #[doc = "< W representation of a quaternion"]
    pub w: f32,
    #[doc = "< X representation of a quaternion"]
    pub x: f32,
    #[doc = "< Y representation of a quaternion"]
    pub y: f32,
    #[doc = "< Z representation of a quaternion"]
    pub z: f32,
}
#[test]
fn bindgen_test_layout_k4a_quaternion_t__wxyz() {
    assert_eq!(
        ::std::mem::size_of::<k4a_quaternion_t__wxyz>(),
        16usize,
        concat!("Size of: ", stringify!(k4a_quaternion_t__wxyz))
    );
    assert_eq!(
        ::std::mem::align_of::<k4a_quaternion_t__wxyz>(),
        4usize,
        concat!("Alignment of ", stringify!(k4a_quaternion_t__wxyz))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k4a_quaternion_t__wxyz>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_quaternion_t__wxyz),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k4a_quaternion_t__wxyz>())).x as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_quaternion_t__wxyz),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k4a_quaternion_t__wxyz>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_quaternion_t__wxyz),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k4a_quaternion_t__wxyz>())).z as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_quaternion_t__wxyz),
            "::",
            stringify!(z)
        )
    );
}
#[test]
fn bindgen_test_layout_k4a_quaternion_t() {
    assert_eq!(
        ::std::mem::size_of::<k4a_quaternion_t>(),
        16usize,
        concat!("Size of: ", stringify!(k4a_quaternion_t))
    );
    assert_eq!(
        ::std::mem::align_of::<k4a_quaternion_t>(),
        4usize,
        concat!("Alignment of ", stringify!(k4a_quaternion_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k4a_quaternion_t>())).wxyz as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_quaternion_t),
            "::",
            stringify!(wxyz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k4a_quaternion_t>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k4a_quaternion_t),
            "::",
            stringify!(v)
        )
    );
}
#[repr(i32)]
#[doc = " k4abt_joint_confidence_level_t"]
#[doc = ""]
#[doc = " \\remarks"]
#[doc = " This enumeration specifies the joint confidence level."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum k4abt_joint_confidence_level_t {
    #[doc = "< The joint is out of range (too far from depth camera)"]
    K4ABT_JOINT_CONFIDENCE_NONE = 0,
    #[doc = "< The joint is not observed (likely due to occlusion), predicted joint pose"]
    K4ABT_JOINT_CONFIDENCE_LOW = 1,
    #[doc = "< Medium confidence in joint pose. Current SDK will only provide joints up to this confidence level"]
    K4ABT_JOINT_CONFIDENCE_MEDIUM = 2,
    #[doc = "< High confidence in joint pose. Placeholder for future SDK"]
    K4ABT_JOINT_CONFIDENCE_HIGH = 3,
    #[doc = "< The total number of confidence levels."]
    K4ABT_JOINT_CONFIDENCE_LEVELS_COUNT = 4,
}
#[doc = " Structure to define a single joint"]
#[doc = ""]
#[doc = " The position and orientation together defines the coordinate system for the given joint. They are defined relative"]
#[doc = " to the sensor global coordinate system."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _k4abt_joint_t {
    #[doc = "< The position of the joint specified in millimeters"]
    pub position: k4a_float3_t,
    #[doc = "< The orientation of the joint specified in normalized quaternion"]
    pub orientation: k4a_quaternion_t,
    #[doc = "< The confidence level of the joint"]
    pub confidence_level: k4abt_joint_confidence_level_t,
}
#[test]
fn bindgen_test_layout__k4abt_joint_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4abt_joint_t>(),
        32usize,
        concat!("Size of: ", stringify!(_k4abt_joint_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4abt_joint_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_k4abt_joint_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4abt_joint_t>())).position as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4abt_joint_t),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4abt_joint_t>())).orientation as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4abt_joint_t),
            "::",
            stringify!(orientation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4abt_joint_t>())).confidence_level as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4abt_joint_t),
            "::",
            stringify!(confidence_level)
        )
    );
}
#[doc = " Structure to define a single joint"]
#[doc = ""]
#[doc = " The position and orientation together defines the coordinate system for the given joint. They are defined relative"]
#[doc = " to the sensor global coordinate system."]
pub type k4abt_joint_t = _k4abt_joint_t;
#[doc = " Structure to define joints for skeleton"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _k4abt_skeleton_t {
    #[doc = "< The joints for the body"]
    pub joints: [k4abt_joint_t; 32usize],
}
#[test]
fn bindgen_test_layout__k4abt_skeleton_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4abt_skeleton_t>(),
        1024usize,
        concat!("Size of: ", stringify!(_k4abt_skeleton_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4abt_skeleton_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_k4abt_skeleton_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4abt_skeleton_t>())).joints as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4abt_skeleton_t),
            "::",
            stringify!(joints)
        )
    );
}
#[doc = " Structure to define joints for skeleton"]
pub type k4abt_skeleton_t = _k4abt_skeleton_t;
#[doc = " Structure to define body"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _k4abt_body_t {
    #[doc = "< An id for the body that can be used for frame-to-frame correlation"]
    pub id: u32,
    #[doc = "< The skeleton information for the body"]
    pub skeleton: k4abt_skeleton_t,
}
#[test]
fn bindgen_test_layout__k4abt_body_t() {
    assert_eq!(
        ::std::mem::size_of::<_k4abt_body_t>(),
        1028usize,
        concat!("Size of: ", stringify!(_k4abt_body_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_k4abt_body_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_k4abt_body_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4abt_body_t>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4abt_body_t),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_k4abt_body_t>())).skeleton as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_k4abt_body_t),
            "::",
            stringify!(skeleton)
        )
    );
}
#[doc = " Structure to define body"]
pub type k4abt_body_t = _k4abt_body_t;
extern "C" {
    #[doc = " Default configuration setting for k4abt tracker."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Use this setting to initialize a \\ref k4abt_tracker_configuration_t to a default state."]
    pub static K4ABT_TRACKER_CONFIG_DEFAULT: k4abt_tracker_configuration_t;
}
extern "C" {
    #[doc = " Create a body tracker handle."]
    #[doc = ""]
    #[doc = " \\param sensor_calibration"]
    #[doc = " The sensor calibration that will be used for capture processing."]
    #[doc = ""]
    #[doc = " \\param config"]
    #[doc = " The configuration we want to run the tracker in. This can be initialized with ::K4ABT_TRACKER_CONFIG_DEFAULT."]
    #[doc = ""]
    #[doc = " \\param tracker_handle"]
    #[doc = " Output parameter which on success will return a handle to the body tracker."]
    #[doc = ""]
    #[doc = " \\relates k4abt_tracker_t"]
    #[doc = ""]
    #[doc = " \\return ::K4A_RESULT_SUCCEEDED if the body tracker handle was created successfully."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " If successful, k4abt_tracker_create() will return a body tracker handle in the tracker parameter. This handle grants"]
    #[doc = " access to the body tracker and may be used in the other k4abt API calls."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " When done with body tracking, close the handle with k4abt_tracker_destroy()."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Only one tracker is allowed to exist at the same time in each process. If you call this API without destroying the"]
    #[doc = " previous tracker you created, the API call will fail."]
    pub fn k4abt_tracker_create(
        sensor_calibration: *const k4a_calibration_t,
        config: k4abt_tracker_configuration_t,
        tracker_handle: *mut k4abt_tracker_t,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Releases a body tracker handle."]
    #[doc = ""]
    #[doc = " \\param tracker_handle"]
    #[doc = " Handle obtained by k4abt_tracker_create()."]
    #[doc = ""]
    #[doc = " \\relates k4abt_tracker_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Once released, the tracker_handle is no longer valid."]
    pub fn k4abt_tracker_destroy(tracker_handle: k4abt_tracker_t);
}
extern "C" {
    #[doc = " Control the temporal smoothing across frames."]
    #[doc = ""]
    #[doc = " \\param tracker_handle"]
    #[doc = " Handle obtained by k4abt_tracker_create()."]
    #[doc = ""]
    #[doc = " \\param smoothing_factor"]
    #[doc = " Set between 0 for no smoothing and 1 for full smoothing. Less smoothing will increase the responsiveness of the"]
    #[doc = " detected skeletons but will cause more positional and orientational jitters."]
    #[doc = ""]
    #[doc = " \\relates k4abt_tracker_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " The default smoothness value is defined as K4ABT_DEFAULT_TRACKER_SMOOTHING_FACTOR."]
    pub fn k4abt_tracker_set_temporal_smoothing(
        tracker_handle: k4abt_tracker_t,
        smoothing_factor: f32,
    );
}
extern "C" {
    #[doc = " Add a k4a sensor capture to the tracker input queue to generate its body tracking result asynchronously."]
    #[doc = ""]
    #[doc = " \\param tracker_handle"]
    #[doc = " Handle obtained by k4abt_tracker_create()."]
    #[doc = ""]
    #[doc = " \\param sensor_capture_handle"]
    #[doc = " Handle to a sensor capture returned by k4a_device_get_capture() from k4a SDK. It should contain the depth data for"]
    #[doc = " this function to work. Otherwise the function will return failure."]
    #[doc = ""]
    #[doc = " \\param timeout_in_ms"]
    #[doc = " Specifies the time in milliseconds the function should block waiting to add the sensor capture to the tracker"]
    #[doc = " process queue. 0 is a check of the status without blocking. Passing a value of #K4A_WAIT_INFINITE will block"]
    #[doc = " indefinitely until the capture is added to the process queue."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_WAIT_RESULT_SUCCEEDED if a sensor capture is successfully added to the processing queue. If the queue is still"]
    #[doc = " full before the timeout elapses, the function will return ::K4A_WAIT_RESULT_TIMEOUT. All other failures will return"]
    #[doc = " ::K4A_WAIT_RESULT_FAILED."]
    #[doc = ""]
    #[doc = " \\relates k4abt_tracker_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Add a k4a capture to the tracker input queue so that it can be processed asynchronously to generate the body tracking"]
    #[doc = " result. The processed results will be added to an output queue maintained by k4abt_tracker_t instance. Call"]
    #[doc = " k4abt_tracker_pop_result to get the result and pop it from the output queue."]
    #[doc = " If the input queue or output queue is full, this function will block up until the timeout is reached."]
    #[doc = " Once body_frame data is read, the user must call k4abt_frame_release() to return the allocated memory to the SDK"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Upon successfully insert a sensor capture to the input queue this function will return success."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " This function returns ::K4A_WAIT_RESULT_FAILED when either the tracker is shut down by k4abt_tracker_shutdown() API,"]
    #[doc = " or an internal problem is encountered before adding to the input queue: such as low memory condition,"]
    #[doc = " sensor_capture_handle not containing the depth data, or other unexpected issues."]
    #[doc = ""]
    pub fn k4abt_tracker_enqueue_capture(
        tracker_handle: k4abt_tracker_t,
        sensor_capture_handle: k4a_capture_t,
        timeout_in_ms: i32,
    ) -> k4a_wait_result_t;
}
extern "C" {
    #[doc = " Gets the next available body frame."]
    #[doc = ""]
    #[doc = " \\param tracker_handle"]
    #[doc = " Handle obtained by k4abt_tracker_create()."]
    #[doc = ""]
    #[doc = " \\param body_frame_handle"]
    #[doc = " If successful this contains a handle to a body frame object. Caller must call k4abt_release_frame() when its done"]
    #[doc = " using this frame."]
    #[doc = ""]
    #[doc = " \\param timeout_in_ms"]
    #[doc = " Specifies the time in milliseconds the function should block waiting for the body frame. 0 is a check of the queue"]
    #[doc = " without blocking. Passing a value of #K4A_WAIT_INFINITE will blocking indefinitely."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " ::K4A_WAIT_RESULT_SUCCEEDED if a body frame is returned. If a body frame is not available before the timeout elapses,"]
    #[doc = " the function will return ::K4A_WAIT_RESULT_TIMEOUT. All other failures will return ::K4A_WAIT_RESULT_FAILED."]
    #[doc = ""]
    #[doc = " \\relates k4abt_tracker_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Retrieves the next available body frame result and pop it from the output queue in the k4abt_tracker_t. If a new body"]
    #[doc = " frame is not currently available, this function will block up until the timeout is reached. The SDK will buffer at"]
    #[doc = " least three body frames worth of data before stopping new capture being queued by k4abt_tracker_enqueue_capture."]
    #[doc = " Once body_frame data is read, the user must call k4abt_frame_release() to return the allocated memory to the SDK."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Upon successfully reads a body frame this function will return success."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " This function returns ::K4A_WAIT_RESULT_FAILED when either the tracker is shut down by k4abt_tracker_shutdown() API"]
    #[doc = " and the remaining tracker queue is empty, or an internal problem is encountered: such as low memory condition, or"]
    #[doc = " other unexpected issues."]
    pub fn k4abt_tracker_pop_result(
        tracker_handle: k4abt_tracker_t,
        body_frame_handle: *mut k4abt_frame_t,
        timeout_in_ms: i32,
    ) -> k4a_wait_result_t;
}
extern "C" {
    #[doc = " Shutdown the tracker so that no further capture can be added to the input queue."]
    #[doc = ""]
    #[doc = " \\param tracker_handle"]
    #[doc = " Handle obtained by k4abt_tracker_create()."]
    #[doc = ""]
    #[doc = " \\relates k4abt_tracker_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Once the tracker is shutdown, k4abt_tracker_enqueue_capture() API will always immediately return failure."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " If there are remaining catpures in the tracker queue after the tracker is shutdown, k4abt_tracker_pop_result() can"]
    #[doc = " still return successfully. Once the tracker queue is empty, the k4abt_tracker_pop_result() call will always immediately"]
    #[doc = " return failure."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " This function may be called while another thread is blocking in k4abt_tracker_enqueue_capture() or k4abt_tracker_pop_result()."]
    #[doc = " Calling this function while another thread is in that function will result in that function returning a failure."]
    #[doc = ""]
    pub fn k4abt_tracker_shutdown(tracker_handle: k4abt_tracker_t);
}
extern "C" {
    #[doc = " Release a body frame back to the SDK"]
    #[doc = ""]
    #[doc = " \\param body_frame_handle"]
    #[doc = " Handle to a body frame object to return to SDK."]
    #[doc = ""]
    #[doc = " \\relates k4abt_frame_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Called when the user is finished using the body frame."]
    pub fn k4abt_frame_release(body_frame_handle: k4abt_frame_t);
}
extern "C" {
    #[doc = " Add a reference to a body frame."]
    #[doc = ""]
    #[doc = " \\param body_frame_handle"]
    #[doc = " Body frame to add a reference to."]
    #[doc = ""]
    #[doc = " \\relates k4abt_frame_t"]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " Call this function to add an additional reference to a body frame. This reference must be removed with"]
    #[doc = " k4abt_frame_release()."]
    #[doc = ""]
    #[doc = " \\remarks"]
    #[doc = " This function is not thread-safe."]
    pub fn k4abt_frame_reference(body_frame_handle: k4abt_frame_t);
}
extern "C" {
    #[doc = " Get the number of people from the k4abt_frame_t"]
    #[doc = ""]
    #[doc = " \\param body_frame_handle"]
    #[doc = " Handle to a body frame object returned by k4abt_tracker_pop_result function."]
    #[doc = ""]
    #[doc = " \\returns Returns the number of detected bodies. 0 if the function fails."]
    #[doc = ""]
    #[doc = " \\relates k4abt_frame_t"]
    #[doc = ""]
    #[doc = " \\remarks Called when the user has received a body frame handle and wants to access the data contained in it."]
    #[doc = ""]
    pub fn k4abt_frame_get_num_bodies(body_frame_handle: k4abt_frame_t) -> u32;
}
extern "C" {
    #[doc = " Get the joint information for a particular person index from the k4abt_frame_t"]
    #[doc = ""]
    #[doc = " \\param body_frame_handle"]
    #[doc = " Handle to a body frame object returned by k4abt_tracker_pop_result function."]
    #[doc = ""]
    #[doc = " \\param index"]
    #[doc = " The index of the body of which the joint information is queried."]
    #[doc = ""]
    #[doc = " \\param skeleton"]
    #[doc = " If successful this contains the body skeleton information."]
    #[doc = ""]
    #[doc = " \\returns ::K4A_RESULT_SUCCEEDED if a valid body skeleton is returned. All failures will return ::K4A_RESULT_FAILED."]
    #[doc = ""]
    #[doc = " \\relates k4abt_frame_t"]
    #[doc = ""]
    #[doc = " \\remarks Called when the user has received a body frame handle and wants to access the data contained in it."]
    #[doc = ""]
    pub fn k4abt_frame_get_body_skeleton(
        body_frame_handle: k4abt_frame_t,
        index: u32,
        skeleton: *mut k4abt_skeleton_t,
    ) -> k4a_result_t;
}
extern "C" {
    #[doc = " Get the body id for a particular person index from the k4abt_frame_t"]
    #[doc = ""]
    #[doc = " \\param body_frame_handle"]
    #[doc = " Handle to a body frame object returned by k4abt_tracker_pop_result function."]
    #[doc = ""]
    #[doc = " \\param index"]
    #[doc = " The index of the body of which the body id information is queried."]
    #[doc = ""]
    #[doc = " \\returns Returns the body id. All failures will return K4ABT_INVALID_BODY_ID."]
    #[doc = ""]
    #[doc = " \\relates k4abt_frame_t"]
    #[doc = ""]
    #[doc = " \\remarks Called when the user has received a body frame handle and wants to access the id of the body given a"]
    #[doc = " particular index."]
    #[doc = ""]
    pub fn k4abt_frame_get_body_id(body_frame_handle: k4abt_frame_t, index: u32) -> u32;
}
extern "C" {
    #[doc = " Get the body frame's device timestamp in microseconds"]
    #[doc = ""]
    #[doc = " \\param body_frame_handle"]
    #[doc = " Handle to a body frame object returned by k4abt_tracker_pop_result function."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " Returns the timestamp of the body frame. If the \\p body_frame_handle is invalid this function will return 0. It is"]
    #[doc = " also possible for 0 to be a valid timestamp originating from the beginning of a recording or the start of streaming."]
    #[doc = ""]
    #[doc = " \\relates k4abt_frame_t"]
    #[doc = ""]
    #[doc = " \\remarks Called when the user has received a body frame handle and wants to access the data contained in it."]
    #[doc = ""]
    pub fn k4abt_frame_get_device_timestamp_usec(body_frame_handle: k4abt_frame_t) -> u64;
}
extern "C" {
    #[doc = " Get the body index map from k4abt_frame_t"]
    #[doc = ""]
    #[doc = " \\param body_frame_handle"]
    #[doc = " Handle to a body frame object returned by k4abt_tracker_pop_result function."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " Call this function to access the body index map image. Release the image with k4a_image_release()."]
    #[doc = ""]
    #[doc = " \\relates k4abt_frame_t"]
    #[doc = ""]
    #[doc = " \\remarks Called when the user has received a body frame handle and wants to access the data contained in it."]
    #[doc = ""]
    #[doc = " \\remarks Body Index map is the body instance segmentation map. Each pixel maps to the corresponding pixel in the"]
    #[doc = " depth image or the ir image. The value for each pixel represents which body the pixel belongs to. It can be either"]
    #[doc = " background (value K4ABT_BODY_INDEX_MAP_BACKGROUND) or the index of a detected k4abt_body_t."]
    pub fn k4abt_frame_get_body_index_map(body_frame_handle: k4abt_frame_t) -> k4a_image_t;
}
extern "C" {
    #[doc = " Get the original capture that is used to calculate the k4abt_frame_t"]
    #[doc = ""]
    #[doc = " \\param body_frame_handle"]
    #[doc = " Handle to a body frame object returned by k4abt_tracker_pop_result function."]
    #[doc = ""]
    #[doc = " \\returns"]
    #[doc = " Call this function to access the original k4a_capture_t. Release this capture with k4a_capture_release()."]
    #[doc = ""]
    #[doc = " \\relates k4abt_frame_t"]
    #[doc = ""]
    #[doc = " \\remarks Called when the user has received a body frame handle and wants to access the data contained in it."]
    #[doc = ""]
    pub fn k4abt_frame_get_capture(body_frame_handle: k4abt_frame_t) -> k4a_capture_t;
}
